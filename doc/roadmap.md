# MCPサーバー 開発ロードマップ

このドキュメントは、MCPサーバーの今後の開発ロードマップを概説します。現在のMCPサーバーは、Swiftコードの基本的な解析、チャンクの抽出、および永続化機能を備えています。今後の開発は、機能の強化、言語サポートの拡張、そしてより高度なコード理解機能の追加に焦点を当てます。

## フェーズ1: コア機能の強化と安定化 (短期)

### 1.1. `SwiftParser` の精度向上 (解決済み)

- `getLineNumber` メソッドの正確性を向上させ、`SourceKitten` のオフセット情報から正確な行番号を導出する。（解決済み）
- `getFunctionContent` メソッドで、関数本体だけでなく、関数全体のコードブロック（シグネチャを含む）を正確に抽出できるようにする。（解決済み）

### 1.2. `analyzeProject` の実用化 (解決済み)

- `AnalysisService.getSwiftFiles` のダミー実装を、指定されたプロジェクトパス内のすべての `.swift` ファイルを再帰的に探索する実際のロジックに置き換える。（解決済み）

### 1.3. エラーハンドリングとロギングの強化 (解決済み)

- 各コンポーネント（`parser`, `analysisService`, `server`）におけるエラーハンドリングをより堅牢にし、適切なロギングメカニズムを導入する。（解決済み）

### 1.4. テストカバレッジの向上 (解決済み)

- 既存のテストに加えて、エッジケースやエラーパスをカバーするテストを追加し、コードの信頼性を高める。（解決済み）

### 1.5. 統合テストの追加 (解決済み)

- MCPサーバーと標準入出力での対話テストを追加し、エンドツーエンドの動作を検証しました。

### 1.6. チャンク永続化層の分離

- `AnalysisService` からチャンクの永続化ロジックを独立したモジュールとして分離します。（詳細は [チャンク永続化層の分離](issues/chunk_storage_separation.md) を参照）

### 1.7. テストカバレッジの不足箇所の解消

- 各コンポーネントのエラーケースや特定のメソッドのテストを追加し、テストカバレッジの不足を解消します。（詳細は [テストカバレッジの不足](issues/test_coverage_gaps.md) を参照）

### 1.8. テスト粒度とモックの改善

- 各コンポーネントの単体テストを導入し、モックを利用してテストの独立性と実行速度を向上させます。（詳細は [テスト: 粒度とモックの利用に関する改善](issues/test_granularity_and_mocking.md) を参照）

## フェーズ2: 言語サポートの拡張 (中期)

### 2.1. モジュール式パーサーの設計 (解決済み)

- `SwiftParser` のように、新しい言語のパーサーを容易に追加できるような抽象化レイヤーを導入する。（解決済み）

### 2.2. オプショナルな言語指定引数の追加

- パーサー機能において、言語指定の引数をオプショナルにし、指定がない場合はファイル拡張子から言語を自動判断する機能を追加します。（詳細は [オプショナルな言語指定引数の追加](issues/feature_optional_language_argument.md) を参照）

### 2.2. Kotlinパーサーの実装 (詳細は [Kotlin対応の現状とロードマップ](kotlin_support.md) を参照)

- **計画:**
  1.  `KotlinParser` の機能強化（外部ツール連携）
      - 関連Issue: `kotlin_parser_feature_enhancement_external_tool_integration.md`
  2.  `KotlinParser` の機能強化（`CodeChunk` への正確な変換）
      - 関連Issue: `kotlin_parser_feature_enhancement_codechunk_conversion.md`
  3.  Kotlin対応のテストカバレッジ向上
      - 関連Issue: `kotlin_support_test_coverage_improvement.md`
  4.  Kotlin対応のパフォーマンス最適化
      - 関連Issue: `kotlin_support_performance_optimization.md`

## フェーズ3: 高度なコード理解機能 (長期)

### 3.1. 依存関係グラフの解析と保持

- コードチャンク間の依存関係（関数呼び出し、変数参照など）を解析するロジックを実装する。
- 解析された依存関係グラフをインメモリで保持する。
- 将来的には、SQLiteなどのローカルデータベースに依存関係グラフを永続化する。

### 3.2. コードチャンクの粒度拡張

- 関数だけでなく、変数、プロパティ、クラス、パッケージなど、より多様な単位でコードチャンクを抽出・管理できるように機能を拡張する。
- 大きな関数を、関数内関数、クロージャ、制御構造ブロック、大きな初期化ブロックなどの単位で分割し、チャンクとして表現する。
- 変数・プロパティ単位でのチャンク取得を追加。
- クラス単位でのチャンク取得を追加。
- これに伴い、`CodeChunk` インターフェースやツール仕様を更新する。
- 巨大関数のページングによるチャンク化戦略を導入する。（詳細は [巨大関数のチャンク化戦略: ページング](chunking_paging_strategy.md) を参照）

### 3.3. セマンティック検索の導入

- コードチャンクや依存関係グラフを利用して、より高度なセマンティック検索機能（例: 特定の機能に関連するコードの検索）を実装する。

### 3.4. ナレッジグラフ構築機能の強化

- 変数・プロパティのデータフロー解析機能を追加。
- 関数コールグラフ構築機能を追加。
- クラスの関係解析機能を追加。
- クラス > 関数 > 変数・プロパティ の入れ子関係解析機能を追加。

### 3.5. ナレッジグラフの永続化

- 現状メモリ上にしかないナレッジグラフを永続化する。
- ローカルに閉じたDBを構築し、ファイルベースのDBを優先する。

### 3.6. ナレッジグラフの図表化機能の追加

- LLMにドキュメンテーションさせるために、ナレッジグラフの図表化機能を追加する。
- シーケンス図、クラス図、オブジェクト図、コールグラフ図、データフロー図の生成機能を追加。
- 一覧表の生成機能を追加。
- インターフェイス仕様書（Swaggerなど、他のフォーマットも検討）の生成機能を追加。
- 図は取り回し良くするため、テキストフォーマット（PlantUML, Mermaid, Dot/Graphviz）で出力できるようにする。

## フェーズ4: デプロイメントと運用 (継続的)

### 4.1. サーバーのパッケージングとデプロイ

- サーバーをスタンドアロンアプリケーションとしてパッケージングし、配布を容易にする。
- Dockerコンテナ化を検討し、異なる環境でのデプロイを簡素化する。

### 4.2. パフォーマンス最適化

- 大規模なコードベースを扱う際のパフォーマンスボトルネックを特定し、最適化を行う。
- キャッシュ戦略の改善や、非同期処理の効率化など。
- **コードチャンクキャッシュ戦略の導入**: `analyze_project` が呼び出されなくてもキャッシュが利用され、ファイルの更新やパーサーの仕様変更に追従できるキャッシュ戦略を実装する。（詳細は [コードチャンクキャッシュ戦略](cache_strategy.md) を参照）

このロードマップは柔軟であり、開発の進捗や新たな要件に基づいて調整される可能性があります。
