# 巨大関数のチャンク化戦略: ページング

## 概要

このドキュメントでは、大規模言語モデル（LLM）のコンテキストウィンドウの制約を考慮し、巨大な関数をより小さな、管理しやすい「ページ」に分割する戦略について詳述します。これは、意味的な分割が複雑であるため、まずは簡易的なアプローチとして導入されます。

## 詳細

### 1. 目的

- 巨大な関数を一度にLLMに渡すことによるコンテキストウィンドウの圧迫を回避する。
- LLMがコードの特定の部分に焦点を当てて分析できるように、段階的にコードを提供する。
- 意味的な分割が困難な場合でも、機械的な分割によりコードチャンクの取得を可能にする。

### 2. 対象ツール

以下のツールがページング機能をサポートします。

- `get_function_chunk`: 特定の関数のコードチャンクを取得するツール。
- `get_chunk`: チャンクIDでコードチャンクを取得するツール。

### 3. ページングのトリガー

チャンクの `content` の行数、またはバイト数が、定義された閾値を超えた場合にページングを適用します。閾値は設定可能とし、デフォルト値を設けます。

- **閾値の例**: 500行、10KBなど。
- **設定方法**: サーバーの設定ファイルや、ツール呼び出し時の引数で指定できるように検討します。

### 4. 応答の追加情報

ページングが適用された場合、既存の `CodeChunk` インターフェースに以下のフィールドを追加し、LLMがページングの状態を理解できるようにします。

- `isPartial: boolean`: このチャンクが完全なコードチャンクの一部である場合に `true`。
- `totalLines: number` (オプション): 元の巨大関数の総行数。
- `currentPage: number` (オプション): 現在のチャンクが何ページ目か。
- `totalPages: number` (オプション): 元の巨大関数の総ページ数。
- `nextPageToken: string` (オプション): 次のページをリクエストするためのトークン。このトークンは、次のページを取得するために `pageToken` 引数として使用されます。
- `prevPageToken: string` (オプション): 前のページをリクエストするためのトークン。このトークンは、前のページを取得するために `pageToken` 引数として使用されます。

また、MCPのツール仕様に基づき、`content` プロパティの先頭に、以下の情報を自然言語で追記します。

- **部分出力の明示**: 「この関数は巨大なため、一部のみを表示しています。」
- **全体に対する部分の明示**: 「(現在のページ)/(総ページ数)ページ目、(開始行)-(終了行)行目」
- **次の/前の部分のリクエスト方法**: 「次の部分を取得するには、`get_function_chunk` ツールに `pageToken: "[nextPageTokenの値]"` を指定してリクエストしてください。前の部分を取得するには、`pageToken: "[prevPageTokenの値]"` を指定してください。」

### 5. リクエストの追加引数

`get_function_chunk` および `get_chunk` ツールに以下のオプショナルな引数を追加します。

- `pageToken: string` (オプション): 特定のページをリクエストするためのトークン。このトークンは、サーバー側でチャンクの範囲を特定するために使用されます。
- `pageSize: number` (オプション): 1ページあたりの行数またはバイト数を指定。この引数が指定された場合、サーバーは指定されたサイズでチャンクを分割します。指定がない場合は、デフォルトの閾値が使用されます。

### 6. ページングのロジック

- サーバー側で、`pageToken` を解析し、対応するチャンクの範囲を特定します。
- `pageToken` は、ファイルパス、関数シグネチャ、開始オフセット、終了オフセット、ページサイズなどの情報をエンコードしたステートレスな文字列とします。これにより、サーバーはセッション状態を保持する必要がなくなります。

## 7. ロードマップにおける位置づけ

このページング戦略は、MCPサーバー開発ロードマップの「フェーズ3: 高度なコード理解機能」の「3.2. コードチャンクの粒度拡張」に関連し、LLMのコンテキストウィンドウの制約を緩和するための初期ステップとなります。
