# コードチャンクキャッシュ戦略

このドキュメントは、MCPサーバーにおけるコードチャンクのキャッシュ戦略について詳述します。`analyze_project` ツールが明示的に呼び出されなくてもキャッシュが利用され、かつファイルの更新やパーサーの仕様変更に追従できるようなメカニズムを導入します。

## 1. 背景と目的

現状、コードチャンクは `analyze_project` ツールが呼び出された際にのみ生成・永続化されます。`get_function_chunk` などのツールが呼び出された際には、その場でファイルが解析されます。これにより、頻繁なファイルアクセスや解析処理が発生し、パフォーマンスのボトルネックとなる可能性があります。

本キャッシュ戦略の目的は、解析済みコードチャンクの再利用を促進し、パフォーマンスを向上させるとともに、キャッシュの鮮度と正確性を保証することです。

## 2. キャッシュの保存場所

コードチャンクは、引き続き `./data/chunks` ディレクトリにJSONファイルとして保存されます。各チャンクファイルは、チャンクのユニークなID（例: `func_myFunction_in_File_swift.json`）に基づいて命名されます。

## 2.1. キャッシュの階層構造

本システムでは、コードチャンクのキャッシュに2層構造を採用しています。

-   **メモリキャッシュ**: `CacheManager` 内で管理されるインメモリキャッシュです。高速なアクセスを提供しますが、メモリ逼迫を防ぐため、`MAX_MEMORY_CACHE_SIZE` (デフォルト: 100エントリ) を超えると、LRU (Least Recently Used) ポリシーに基づいて最も長い間アクセスされていないエントリが自動的に破棄されます。
-   **ファイルキャッシュ**: `./data/chunks` ディレクトリにJSONファイルとして永続化されるキャッシュです。メモリキャッシュから破棄されたチャンクや、`analyzeProject` ツールによる初回解析時に保存されるすべてのチャンクがここに格納されます。メモリキャッシュに存在しないチャンクは、必要に応じてファイルキャッシュから読み込まれます。

## 3. キャッシュのキーとメタデータ

各コードチャンクファイルには、そのチャンクの生成に関するメタデータを含むヘッダー情報（または別途メタデータファイル）を付与します。これにより、キャッシュの有効性を判断します。

### 3.1. メタデータ項目

以下の情報をチャンクファイルに含めるか、別途メタデータファイルとして保存します。

- `chunkId`: チャンクのユニークなID。
- `filePath`: 元のソースファイルの絶対パス。
- `fileLastModified`: 元のソースファイルの最終更新日時（タイムスタンプ）。
- `parserVersion`: チャンクを生成したパーサーのバージョン（例: `SwiftParser` のバージョン、`KotlinParser` のバージョン）。
- `parserConfigHash`: パーサーの設定（例: 外部ツールのバージョン、解析オプションなど）のハッシュ値。これにより、パーサーの内部的な仕様変更を検知します。
- `mcpServerVersion`: チャンクを生成したMCPサーバーのバージョン。
- `generatedAt`: チャンクが生成された日時。

### 3.2. キャッシュキーの生成

キャッシュのキーは、`chunkId` と `filePath` の組み合わせを基本とします。これにより、特定のファイル内の特定のチャンクを一意に識別します。

## 4. キャッシュの利用と更新ロジック

`AnalysisService` の `getChunk` メソッド（および `getFunctionChunk` など、チャンクを必要とする他のメソッド）は、`CacheManager` を介して以下のロジックでキャッシュを利用・更新します。

1.  **メモリキャッシュの確認**: まず、`CacheManager` のメモリキャッシュに要求されたチャンクIDが存在するかを確認します。存在すれば、そのチャンクを返します。
2.  **ファイルキャッシュの確認**: メモリキャッシュに存在しない場合、`CacheManager` は `./data/chunks` ディレクトリのファイルキャッシュからチャンクを読み込もうとします。
3.  **メタデータの読み込みと有効性判断**: ファイルキャッシュにチャンクファイルが存在する場合、そのメタデータを読み込みます。以下の条件をすべて満たす場合、キャッシュは有効と判断し、そのチャンクをメモリキャッシュに追加した上で返します。
    - `filePath` が元のソースファイルのパスと一致する。
    - `fileLastModified` が元のソースファイルの現在の最終更新日時と一致する。
    - `parserVersion` が現在のパーサーのバージョンと一致する。
    - `parserConfigHash` が現在のパーサーの設定ハッシュと一致する。
    - `mcpServerVersion` が現在のMCPサーバーのバージョンと一致する。
4.  **キャッシュの無効化と再生成**: 上記の条件のいずれかが満たされない場合、またはファイルキャッシュにも存在しない場合、キャッシュは無効と判断します。この場合、以下の処理を行います。
    - 既存の無効なチャンクファイルを削除します（存在する場合）。
    - 元のソースファイルを再解析し、新しいチャンクを生成します。
    - 新しいチャンクを更新されたメタデータとともにファイルキャッシュに保存し、メモリキャッシュにも追加します。
    - 生成された新しいチャンクを返します。
5.  **`analyzeProject` ツールによる初回生成**: `analyzeProject` ツールが呼び出された際には、プロジェクト内のすべてのファイルが解析され、生成されたコードチャンクは直接 `CacheManager` を介してメモリキャッシュとファイルキャッシュの両方に保存されます。

## 5. ロードマップにおける位置づけ

このキャッシュ戦略は、MCPサーバー開発ロードマップの「フェーズ4: デプロイメントと運用」における「パフォーマンス最適化」の一部として位置づけられます。また、`AnalysisService` のコア機能の強化にも寄与します。

## 6. 考慮事項

- **パーサーのバージョン管理**: 各パーサー（`SwiftParser`, `KotlinParser` など）にバージョン番号を付与するメカニズムが必要です。
- **パーサー設定のハッシュ化**: 外部ツールのバージョンや解析オプションなど、パーサーの設定をハッシュ化するロジックが必要です。
- **ファイル変更の監視**: 大規模なプロジェクトの場合、すべてのファイルの変更日時を常にチェックするのは非効率的です。inotifyなどのファイルシステムイベント監視メカニズムの導入も将来的に検討します。
- **キャッシュのクリーンアップ**: 不要になった古いチャンクファイル（例: ソースファイルが削除された場合など）を定期的にクリーンアップするメカニズムも必要です。
