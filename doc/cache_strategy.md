# コードチャンクキャッシュ戦略

このドキュメントは、MCPサーバーにおけるコードチャンクのキャッシュ戦略について詳述します。`analyze_project` ツールが明示的に呼び出されなくてもキャッシュが利用され、かつファイルの更新やパーサーの仕様変更に追従できるようなメカニズムを導入します。

## 1. 背景と目的

現状、コードチャンクは `analyze_project` ツールが呼び出された際にのみ生成・永続化されます。`get_function_chunk` などのツールが呼び出された際には、その場でファイルが解析されます。これにより、頻繁なファイルアクセスや解析処理が発生し、パフォーマンスのボトルネックとなる可能性があります。

本キャッシュ戦略の目的は、解析済みコードチャンクの再利用を促進し、パフォーマンスを向上させるとともに、キャッシュの鮮度と正確性を保証することです。

## 2. キャッシュの保存場所

コードチャンクは、引き続き `./data/chunks` ディレクトリにJSONファイルとして保存されます。各チャンクファイルは、チャンクのユニークなID（例: `func_myFunction_in_File_swift.json`）に基づいて命名されます。

## 3. キャッシュのキーとメタデータ

各コードチャンクファイルには、そのチャンクの生成に関するメタデータを含むヘッダー情報（または別途メタデータファイル）を付与します。これにより、キャッシュの有効性を判断します。

### 3.1. メタデータ項目

以下の情報をチャンクファイルに含めるか、別途メタデータファイルとして保存します。

- `chunkId`: チャンクのユニークなID。
- `filePath`: 元のソースファイルの絶対パス。
- `fileLastModified`: 元のソースファイルの最終更新日時（タイムスタンプ）。
- `parserVersion`: チャンクを生成したパーサーのバージョン（例: `SwiftParser` のバージョン、`KotlinParser` のバージョン）。
- `parserConfigHash`: パーサーの設定（例: 外部ツールのバージョン、解析オプションなど）のハッシュ値。これにより、パーサーの内部的な仕様変更を検知します。
- `mcpServerVersion`: チャンクを生成したMCPサーバーのバージョン。
- `generatedAt`: チャンクが生成された日時。

### 3.2. キャッシュキーの生成

キャッシュのキーは、`chunkId` と `filePath` の組み合わせを基本とします。これにより、特定のファイル内の特定のチャンクを一意に識別します。

## 4. キャッシュの利用と更新ロジック

`AnalysisService` の `getChunk` メソッド（および `getFunctionChunk` など、チャンクを必要とする他のメソッド）は、以下のロジックでキャッシュを利用・更新します。

1.  **キャッシュの存在確認**: 要求されたチャンクIDに対応するファイルが `./data/chunks` に存在するかを確認します。
2.  **メタデータの読み込み**: チャンクファイルが存在する場合、そのメタデータを読み込みます。
3.  **キャッシュの有効性判断**: 以下の条件をすべて満たす場合、キャッシュは有効と判断し、そのチャンクを返します。
    - `filePath` が元のソースファイルのパスと一致する。
    - `fileLastModified` が元のソースファイルの現在の最終更新日時と一致する。
    - `parserVersion` が現在のパーサーのバージョンと一致する。
    - `parserConfigHash` が現在のパーサーの設定ハッシュと一致する。
    - `mcpServerVersion` が現在のMCPサーバーのバージョンと一致する。
4.  **キャッシュの無効化と再生成**: 上記の条件のいずれかが満たされない場合、キャッシュは無効と判断します。この場合、以下の処理を行います。
    - 既存の無効なチャンクファイルを削除します。
    - 元のソースファイルを再解析し、新しいチャンクを生成します。
    - 新しいチャンクを更新されたメタデータとともに保存します。
    - 生成された新しいチャンクを返します。
5.  **キャッシュの初回生成**: チャンクファイルが存在しない場合、元のソースファイルを解析し、新しいチャンクを生成・保存し、そのチャンクを返します。

## 5. ロードマップにおける位置づけ

このキャッシュ戦略は、MCPサーバー開発ロードマップの「フェーズ4: デプロイメントと運用」における「パフォーマンス最適化」の一部として位置づけられます。また、`AnalysisService` のコア機能の強化にも寄与します。

## 6. 考慮事項

- **パーサーのバージョン管理**: 各パーサー（`SwiftParser`, `KotlinParser` など）にバージョン番号を付与するメカニズムが必要です。
- **パーサー設定のハッシュ化**: 外部ツールのバージョンや解析オプションなど、パーサーの設定をハッシュ化するロジックが必要です。
- **ファイル変更の監視**: 大規模なプロジェクトの場合、すべてのファイルの変更日時を常にチェックするのは非効率的です。inotifyなどのファイルシステムイベント監視メカニズムの導入も将来的に検討します。
- **キャッシュのクリーンアップ**: 不要になった古いチャンクファイル（例: ソースファイルが削除された場合など）を定期的にクリーンアップするメカニズムも必要です。
