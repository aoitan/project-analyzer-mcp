# MCPサーバー ツール仕様

## 1. 目的
このドキュメントは、MCPサーバーが提供するツールの詳細な仕様を定義します。これらのツールは、大規模言語モデル（LLM）が大規模なソースコードを効率的に理解し、操作できるように設計されています。

## 2. 全体的な設計原則

### 2.1. LLMとの連携
*   MCPサーバーは、ContinueなどのAgentから問い合わせ可能なインターフェースを提供します。
*   LLMのコンテキストウィンドウの制約を考慮し、大きなソースファイルを直接渡すのではなく、LLMが必要に応じてコードチャンクを要求できるメカニズムを提供します。

### 2.2. 言語サポート
*   **初期対応**: Swift
*   **将来的な拡張**: Kotlinなど、他の言語への対応を容易にするため、設計段階から解析ロジックをモジュール化し、言語パーサーの入れ替えを可能にします。
*   **外部ツールの活用**: 各言語の解析には、自作ではなく既存の外部ツール（例: Swiftの場合はSourceKitten）を積極的に活用します。

### 2.3. コードチャンクの粒度
*   **初期対応**: 関数単位のコードチャンク取得
*   **将来的な拡張**: 変数、プロパティ、クラス、パッケージなど、より多様な単位でのチャンク取得に対応できるよう、設計段階から柔軟なチャンク取得要求に対応できる構造とします。
*   **チャンクID**: 現在はシグネチャをチャンクIDとして使用しています。

### 2.4. 依存関係グラフとキャッシュ
*   **依存関係グラフ**: 現在は解析していません。
    *   **将来**: メモリ上での保持から開始し、最終的には不揮発性ストレージ（例: SQLite）への保存を検討します。
*   **コードチャンクキャッシュ**: 現在はインメモリキャッシュとファイルシステムへの永続化を実装済みです。
    *   **将来**: 高速な取得のためにキャッシュメカニズムを導入します。
*   **ローカル環境への閉鎖**: 依存関係グラフやコードキャッシュは、SQLiteやファイルシステムを活用し、ローカル環境に閉じた形で管理します。

### 2.5. 開発技術スタック
*   **言語**: TypeScript
*   **ランタイム**: Node.js
*   **SDK**: `@modelcontextprotocol/sdk` を活用します。
*   **テスト**: ユニットテストを重視し、コードの品質と信頼性を確保します。

### 2.6. ドキュメンテーション
*   設計ドキュメント（本ドキュメントを含む）およびREADMEを適切に用意し、プロジェクトの理解とメンテナンスを容易にします。

## 3. ツール仕様

### 3.1. `list_functions_in_file`

#### 3.1.1. 目的
指定されたソースファイルに含まれる関数の一覧を返します。LLMがファイルの全体像を把握し、特定の関数に焦点を当てるための足がかりを提供します。

#### 3.1.2. 入力
*   **`filePath`**: `string`
    *   解析対象のソースファイルの絶対パス。

#### 3.1.3. 出力
*   **`functions`**: `Array<object>`
    *   ファイル内で見つかった関数のリスト。各オブジェクトは以下のプロパティを持ちます。
        *   **`signature`**: `string`
            *   関数のシグネチャ（例: `func myFunction(param: String) -> Int`）。
            *   **備考**: 現在はシグネチャを返しており、これをチャンクIDとして使用しています。
        *   **`id`**: `string` (オプション、将来的に導入)
            *   関数のユニークな識別子。チャンクIDとして機能し、他のチャンク種別（変数、プロパティなど）と統一的に扱えるようにします。

#### 3.1.4. 動作概要
1.  `filePath` で指定されたファイルを読み込みます。
2.  言語パーサー（Swiftの場合はSourceKittenなど）を使用してファイルを解析します。
3.  解析結果から関数定義を抽出し、そのシグネチャのリストを生成します。
4.  リストを返します。

### 3.2. `get_function_chunk`

#### 3.2.1. 目的
指定されたソースファイル内の特定の関数のコードチャンク（内容）を返します。LLMが特定の関数の詳細な実装を分析するために使用します。

#### 3.2.2. 入力
*   **`filePath`**: `string`
    *   対象のソースファイルの絶対パス。
*   **`functionSignature`**: `string`
    *   取得したい関数のシグネチャ。
    *   **備考**: 現在はシグネチャをチャンクIDとして使用し、コードチャンクを検索しています。

#### 3.2.3. 出力
*   **`chunk`**: `object`
    *   取得されたコードチャンクのオブジェクト。
        *   **`content`**: `string`
            *   関数の完全なコード内容。
        *   **`id`**: `string` (オプション、将来的に導入)
            *   コードチャンクのユニークな識別子。

#### 3.2.4. 動作概要
1.  `filePath` で指定されたファイルを読み込みます。
2.  言語パーサーを使用してファイルを解析し、関数定義を特定します。
3.  `functionSignature` に一致する関数を見つけます。
4.  見つかった関数のコードブロック全体を抽出し、`content` として返します。
5.  関数が見つからない場合はエラーを返します。

### 3.3. `analyze_project`

#### 3.3.1. 目的
指定されたプロジェクトを解析し、コードチャンクを抽出し、インメモリキャッシュとファイルシステムに保存します。

#### 3.3.2. 入力
*   **`projectPath`**: `string`
    *   解析対象のプロジェクトの絶対パス。

#### 3.3.3. 出力
*   **`status`**: `string`
    *   処理結果のステータス（例: `success`）。
*   **`message`**: `string`
    *   処理結果に関するメッセージ。

#### 3.3.4. 動作概要
1.  `projectPath` で指定されたプロジェクト内のSwiftファイルを検索します。
2.  各Swiftファイルを解析し、関数単位のコードチャンクを抽出します。
3.  抽出されたコードチャンクをインメモリキャッシュに保存し、同時にファイルシステム（`data/chunks/`）にJSON形式で永続化します。

### 3.4. `get_chunk`

#### 3.4.1. 目的
指定されたチャンクIDに対応するコードチャンクの内容を返します。

#### 3.4.2. 入力
*   **`chunkId`**: `string`
    *   取得したいコードチャンクのユニークな識別子（現在は関数のシグネチャ）。

#### 3.4.3. 出力
*   **`status`**: `string`
    *   処理結果のステータス（例: `success`、`error`）。
*   **`chunk`**: `string`
    *   取得されたコードチャンクの完全な内容。
*   **`message`**: `string` (オプション)
    *   エラー発生時のメッセージ。

#### 3.4.4. 動作概要
1.  `chunkId` で指定されたチャンクをインメモリキャッシュから検索します。
2.  キャッシュに見つからない場合、ファイルシステム（`data/chunks/`）からチャンクをロードします。
3.  チャンクが見つかった場合、その内容を返します。見つからない場合はエラーを返します。
