# MCPサーバー ツール仕様

## 1. 目的

このドキュメントは、MCPサーバーが提供するツールの詳細な仕様を定義します。これらのツールは、大規模言語モデル（LLM）が大規模なソースコードを効率的に理解し、操作できるように設計されています。

## 2. 全体的な設計原則

### 2.1. LLMとの連携

- MCPサーバーは、ContinueなどのAgentから問い合わせ可能なインターフェースを提供します。
- LLMのコンテキストウィンドウの制約を考慮し、大きなソースファイルを直接渡すのではなく、LLMが必要に応じてコードチャンクを要求できるメカニズムを提供します。

### 2.2. 言語サポート

- **初期対応**: Swift
- **将来的な拡張**: Kotlinなど、他の言語への対応を容易にするため、設計段階から解析ロジックをモジュール化し、言語パーサーの入れ替えを可能にします。
- **外部ツールの活用**: 各言語の解析には、自作ではなく既存の外部ツール（例: Swiftの場合はSourceKitten）を積極的に活用します。

### 2.3. コードチャンクの粒度

- **初期対応**: 関数単位のコードチャンク取得
- **将来的な拡張**: 変数、プロパティ、クラス、パッケージなど、より多様な単位でのチャンク取得に対応できるよう、設計段階から柔軟なチャンク取得要求に対応できる構造とします。
- **チャンクID**: 現在はシグネチャをチャンクIDとして使用しています。

### 2.4. 依存関係グラフとキャッシュ

- **依存関係グラフ**: 現在は解析していません。
  - **将来**: メモリ上での保持から開始し、最終的には不揮発性ストレージ（例: SQLite）への保存を検討します。
- **コードチャンクキャッシュ**: 現在はインメモリキャッシュとファイルシステムへの永続化を実装済みです。
  - **将来**: 高速な取得のためにキャッシュメカニズムを導入します。
- **ローカル環境への閉鎖**: 依存関係グラフやコードキャッシュは、SQLiteやファイルシステムを活用し、ローカル環境に閉じた形で管理します。

### 2.5. 開発技術スタック

- **言語**: TypeScript
- **ランタイム**: Node.js
- **SDK**: `@modelcontextprotocol/sdk` を活用します。
- **テスト**: ユニットテストを重視し、コードの品質と信頼性を確保します。

### 2.6. ドキュメンテーション

- 設計ドキュメント（本ドキュメントを含む）およびREADMEを適切に用意し、プロジェクトの理解とメンテナンスを容易にします。

## 3. ツール仕様

### 3.1. `find_file`

#### 3.1.1. 目的

指定されたパターンに一致するファイルの絶対パスのリストを返します。LLMが曖昧なファイル名や部分的なパスから目的のファイルを特定するために使用します。

#### 3.1.2. 入力

- **`pattern`**: `string`
  - 検索対象のファイル名の一部、またはglobパターン（例: `*.swift`, `src/**/*.swift`）。

#### 3.1.3. 出力

- **`content`**: `Array<object>`
  - 処理結果のコンテンツ。以下の形式のオブジェクトを一つ含みます。
    - **`type`**: `string` (`"text"`)
    - **`text`**: `string`
      - パターンに一致するファイルの絶対パスのリストをJSON文字列化したもの。

#### 3.1.4. 動作概要

1.  `pattern` で指定されたパターンに一致するファイルをプロジェクト内で検索します。
2.  一致するファイルの絶対パスのリストを返します。

### 3.2. `find_function`

#### 3.2.1. 目的

指定されたファイル内で、関数名または部分的なシグネチャに一致する関数のチャンクIDとシグネチャのリストを返します。LLMが曖昧な関数名から目的の関数を特定するために使用します。

#### 3.2.2. 入力

- **`filePath`**: `string`
  - 検索対象のソースファイルの絶対パス。
- **`functionQuery`**: `string`
  - 検索対象の関数名、または部分的なシグネチャ。
- **`language`**: `string` (オプション)
  - 解析対象ファイルの言語（例: `swift`, `kotlin`）。指定がない場合、ファイル拡張子から自動的に判断されます。

#### 3.2.3. 出力

- **`content`**: `Array<object>`
  - 処理結果のコンテンツ。以下の形式のオブジェクトを一つ含みます。
    - **`type`**: `string` (`"text"`)
    - **`text`**: `string`
      - ファイル内で見つかった関数のリストをJSON文字列化したもの。各オブジェクトは以下のプロパティを持ちます。
        - **`id`**: `string`
          - 関数のユニークなチャンクID。
        - **`signature`**: `string`
          - 関数の完全なシグネチャ（例: `func myFunction(param: String) -> Int`）。

#### 3.2.4. 動作概要

1.  `filePath` で指定されたファイルを解析します。
2.  `functionQuery` に一致する関数を検索します。
3.  一致する関数のチャンクIDとシグネチャのリストを返します。

### 3.3. `list_functions_in_file` (更新)

#### 3.3.1. 目的

指定されたソースファイルに含まれる関数の一覧をチャンクIDとシグネチャの形式で返します。LLMがファイルの全体像を把握し、特定の関数に焦点を当てるための足がかりを提供します。

#### 3.3.2. 入力

- **`filePath`**: `string`
  - 解析対象のソースファイルの絶対パス。
- **`language`**: `string` (オプション)
  - 解析対象ファイルの言語（例: `swift`, `kotlin`）。指定がない場合、ファイル拡張子から自動的に判断されます。

#### 3.3.3. 出力

- **`content`**: `Array<object>`
  - 処理結果のコンテンツ。以下の形式のオブジェクトを一つ含みます。
    - **`type`**: `string` (`"text"`)
    - **`text`**: `string`
      - ファイル内で見つかった関数のリストをJSON文字列化したもの。各オブジェクトは以下のプロパティを持ちます。
        - **`id`**: `string`
          - 関数のユニークなチャンクID。
        - **`signature`**: `string`
          - 関数のシグネチャ（例: `func myFunction(param: String) -> Int`）。

#### 3.3.4. 動作概要

1.  `filePath` で指定されたファイルを読み込みます。
2.  言語パーサー（Swiftの場合はSourceKittenなど）を使用してファイルを解析します。
3.  解析結果から関数定義を抽出し、そのチャンクIDとシグネチャのリストを生成します。
4.  リストを返します。

### 3.4. `get_function_chunk` (更新)

#### 3.4.1. 目的

指定されたチャンクIDに対応する関数のコードチャンク（内容）を返します。LLMが特定の関数の詳細な実装を分析するために使用します。

#### 3.4.2. 入力

- **`filePath`**: `string`
  - 取得したい関数の含まれるソースファイルの絶対パス。
- **`functionSignature`**: `string`
  - 取得したい関数のシグネチャ。
- **`language`**: `string` (オプション)
  - 解析対象ファイルの言語（例: `swift`, `kotlin`）。指定がない場合、ファイル拡張子から自動的に判断されます。

#### 3.4.3. 出力

- **`content`**: `Array<object>`
  - 処理結果のコンテンツ。以下の形式のオブジェクトを一つ含みます。
    - **`type`**: `string` (`"text"`)
    - **`text`**: `string`
      - 関数の完全なコード内容（シグネチャ、コメント、本体などを含む）。
- **`isError`**: `boolean` (オプション)
  - エラーが発生した場合に `true`。

#### 3.4.4. 動作概要

1.  `filePath` と `functionSignature` で指定された関数を検索します。
2.  見つかった関数のコードブロック全体を抽出し、`content` として返します。
3.  関数が見つからない場合は `isError: true` とメッセージを返します。

### 3.5. `analyze_project`

#### 3.5.1. 目的

指定されたプロジェクトを解析し、コードチャンクを抽出し、インメモリキャッシュとファイルシステムに保存します。

#### 3.5.2. 入力

- **`projectPath`**: `string`
  - 解析対象のプロジェクトの絶対パス。

#### 3.5.3. 出力

- **`status`**: `string`
  - 処理結果のステータス（例: `success`）。
- **`message`**: `string`
  - 処理結果に関するメッセージ。

#### 3.5.4. 動作概要

1.  `projectPath` で指定されたプロジェクト内のSwiftファイルを検索します。
2.  各Swiftファイルを解析し、関数単位のコードチャンクを抽出します。
3.  抽出されたコードチャンクをインメモリキャッシュに保存し、同時にファイルシステム（`data/chunks/`）にJSON形式で永続化します。

### 3.6. `get_chunk`

#### 3.6.1. 目的

指定されたチャンクIDに対応するコードチャンクの内容を返します。

#### 3.6.2. 入力

- **`chunkId`**: `string`
  - 取得したいコードチャンクのユニークな識別子。

#### 3.6.3. 出力

- **`content`**: `Array<object>`
  - 処理結果のコンテンツ。以下の形式のオブジェクトを一つ含みます。
    - **`type`**: `string` (`"text"`)
    - **`text`**: `string`
      - 取得されたコードチャンクの完全な内容。
- **`isError`**: `boolean` (オプション)
  - エラーが発生した場合に `true`。

#### 3.6.4. 動作概要

1.  `chunkId` で指定されたチャンクをインメモリキャッシュから検索します。
2.  キャッシュに見つからない場合、ファイルシステム（`data/chunks/`）からチャンクをロードします。
3.  チャンクが見つかった場合、その内容を返します。見つからない場合は `isError: true` とメッセージを返します。
