# MCPサーバー ツール仕様

## 1. 目的
このドキュメントは、MCPサーバーが提供するツールの詳細な仕様を定義します。これらのツールは、大規模言語モデル（LLM）が大規模なソースコードを効率的に理解し、操作できるように設計されています。

## 2. 全体的な設計原則

### 2.1. LLMとの連携
*   MCPサーバーは、ContinueなどのAgentから問い合わせ可能なインターフェースを提供します。
*   LLMのコンテキストウィンドウの制約を考慮し、大きなソースファイルを直接渡すのではなく、LLMが必要に応じてコードチャンクを要求できるメカニズムを提供します。

### 2.2. 言語サポート
*   **初期対応**: Swift
*   **将来的な拡張**: Kotlinなど、他の言語への対応を容易にするため、設計段階から解析ロジックをモジュール化し、言語パーサーの入れ替えを可能にします。
*   **外部ツールの活用**: 各言語の解析には、自作ではなく既存の外部ツール（例: Swiftの場合はSourceKitten）を積極的に活用します。

### 2.3. コードチャンクの粒度
*   **初期対応**: 関数単位のコードチャンク取得
*   **将来的な拡張**: 変数、プロパティ、クラス、パッケージなど、より多様な単位でのチャンク取得に対応できるよう、設計段階から柔軟なチャンク取得要求に対応できる構造とします。
*   **チャンクID**: 最初はステートレスなシグネチャベースの運用としますが、将来的にチャンクIDを導入し、異なるチャンク種別を統一的に扱えるようにします。

### 2.4. 依存関係グラフとキャッシュ
*   **依存関係グラフ**:
    *   **初期**: 解析しません。
    *   **将来**: メモリ上での保持から開始し、最終的には不揮発性ストレージ（例: SQLite）への保存を検討します。
*   **コードチャンクキャッシュ**:
    *   **初期**: キャッシュしません。
    *   **将来**: 高速な取得のためにキャッシュメカニズムを導入します。
*   **ローカル環境への閉鎖**: 依存関係グラフやコードキャッシュは、SQLiteやファイルシステムを活用し、ローカル環境に閉じた形で管理します。

### 2.5. 開発技術スタック
*   **言語**: TypeScript
*   **ランタイム**: Node.js
*   **SDK**: `@modelcontextprotocol/sdk` を活用します。
*   **テスト**: ユニットテストを重視し、コードの品質と信頼性を確保します。

### 2.6. ドキュメンテーション
*   設計ドキュメント（本ドキュメントを含む）およびREADMEを適切に用意し、プロジェクトの理解とメンテナンスを容易にします。

## 3. ツール仕様

### 3.1. `list_functions_in_file`

#### 3.1.1. 目的
指定されたソースファイルに含まれる関数の一覧を返します。LLMがファイルの全体像を把握し、特定の関数に焦点を当てるための足がかりを提供します。

#### 3.1.2. 入力
*   **`filePath`**: `string`
    *   解析対象のソースファイルの絶対パス。

#### 3.1.3. 出力
*   **`functions`**: `Array<object>`
    *   ファイル内で見つかった関数のリスト。各オブジェクトは以下のプロパティを持ちます。
        *   **`signature`**: `string`
            *   関数のシグネチャ（例: `func myFunction(param: String) -> Int`）。
            *   **備考**: 最初はシグネチャを返しますが、将来的にコードチャンクをキャッシュし、関数IDと対応付けることで、より効率的な参照を可能にします。
        *   **`id`**: `string` (オプション、将来的に導入)
            *   関数のユニークな識別子。チャンクIDとして機能し、他のチャンク種別（変数、プロパティなど）と統一的に扱えるようにします。

#### 3.1.4. 動作概要
1.  `filePath` で指定されたファイルを読み込みます。
2.  言語パーサー（Swiftの場合はSourceKittenなど）を使用してファイルを解析します。
3.  解析結果から関数定義を抽出し、そのシグネチャのリストを生成します。
4.  リストを返します。

### 3.2. `get_function_chunk`

#### 3.2.1. 目的
指定されたソースファイル内の特定の関数のコードチャンク（内容）を返します。LLMが特定の関数の詳細な実装を分析するために使用します。

#### 3.2.2. 入力
*   **`filePath`**: `string`
    *   対象のソースファイルの絶対パス。
*   **`functionSignature`**: `string`
    *   取得したい関数のシグネチャ。
    *   **備考**: 最初はシグネチャから関数を検索しますが、将来的に関数IDからコードチャンクキャッシュを引く形に移行します。

#### 3.2.3. 出力
*   **`chunk`**: `object`
    *   取得されたコードチャンクのオブジェクト。
        *   **`content`**: `string`
            *   関数の完全なコード内容。
        *   **`id`**: `string` (オプション、将来的に導入)
            *   コードチャンクのユニークな識別子。

#### 3.2.4. 動作概要
1.  `filePath` で指定されたファイルを読み込みます。
2.  言語パーサーを使用してファイルを解析し、関数定義を特定します。
3.  `functionSignature` に一致する関数を見つけます。
4.  見つかった関数のコードブロック全体を抽出し、`content` として返します。
5.  関数が見つからない場合はエラーを返します。
