# LLM向けコード解析・ナレッジグラフの仕様策定

本ドキュメントでは、LLMを活用した大規模リポジトリのコード解析において、どのように全体像を把握し、コンテキストの制約を克服すべきか、そのためのアプローチと必要なツール要件を定義します。

## 0. 【重要】既存ロードマップと本議論によるアプローチの深化（差分）

本プロジェクトの既存ロードマップ（`doc/roadmap.md`）では、「フェーズ3: 高度なコード理解機能」として、依存関係グラフの解析・保持、データフロー/関数コールグラフ/クラス関係の解析、およびそれらのローカルDBへの永続化が定義されています。
今回の仕様策定における最大の差分（深化）は、これらナレッジグラフを**「どのように構築・永続化し、LLMにどう使わせるか」というアーキテクチャ上のパラダイムを、より現実的かつLLM（RAG）に最適化された形へシフトさせる点**にあります。

| 観点                             | 既存ロードマップの素直な延長線                                                                                                            | 本仕様策定によるハイブリッド・RAGアプローチ                                                                                                                             |
| :------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ナレッジグラフの構築・維持**   | 自前のパーサーまたは解析ロジックでコードベース全体を解析し、巨大な依存関係グラフ全体を構築・DBへ永続化し続ける。（ctags的な陳腐化の懸念） | **LSP（SourceKit-LSP等）やTree-sitter等の既存外部ツールへ重い解析処理を委譲（ハイブリッド）**し、MCPはLLM向けグラフ（JSON等）への「変換・キャッシュ・中継役」に徹する。 |
| **グラフの更新（陳腐化対策）**   | 変更があるたびに全体（または広い範囲）を再解析・保存し直す。                                                                              | **オンデマンド（Lazy）エッジ更新**。LLMが要求した瞬間に起点ファイルの差分を検知し、必要な部分ツリーだけを再パース・更新する。                                           |
| **LLMへの情報の渡し方**          | （LLMにドキュメンテーションさせるため）ナレッジグラフからUMLや一覧表といった静的な図表を生成して返す。                                    | 図表生成にこだわらず、LLMが自在にアクション（探索）できる**「動的ナビゲーションAPI（Graph RAG）」**を提供する。                                                         |
| **優先順位（アプローチの方向）** | 関数や変数など、より細かい単位（ボトムアップ）の解像度を上げることに注力しがちになる。                                                    | まず**「クラスリレーション（アーキテクチャの骨格）」を最優先（Phase1）**とし、次に「コールグラフ（血流）」（Phase2）へ段階的に進めるトップダウン志向へ明確化。          |

※ 以前の議論案にあった「ローカルSLMを内包する/しない」「DeepWikiを作る」といった構想は既存のロードマップには含まれていないため（実装予定外の幻覚であったため）、本仕様からは除外し、純粋に「コード解析・ナレッジグラフ構築手段の最適化」に論点を絞ります。

以降のセクションでは、この「ハイブリッド＆オンデマンド方針」に基づく詳細なアプローチとアーキテクチャを定義します。

## 1. LLM固有のコード解析アプローチと課題

人間が未知の大規模コードベースを解析する際、通常はトップダウン（アーキテクチャやディレクトリ構造の俯瞰）とボトムアップ（個別の関数やクラスの実装詳細）を行き来しながら理解を深めます。これをLLMに適用する場合、特有の強みと制約に直面します。

### LLMの強み

- **高速な局所的理解**: 与えられた関数やクラスの目的、実装意図を即座に言語化する。
- **パターン認識**: 類似の実装やアンチパターン、一般的なアーキテクチャの構成要素を見つけ出す。
- **自然言語による要約**: コードの挙動を仕様として高い精度で翻訳・要約できる。

### LLMの制約（コンテキスト長と認知限界）

- **コンテキストウィンドウの枯渇**: 数万〜数十万行を超えるリポジトリ全体を一度のプロンプトに含めることは不可能（または極めて非効率でコスト高）。
- **「Lost in the Middle」現象**: 大量の情報を一度に与えられた場合、中間の重要な情報を見落としたり、文脈の接続が曖昧になる傾向がある。
- **「なんとなく」の要約による情報劣化**: チャンクごとに読んだ情報を単純に要約していくと、「AはBである」「CはDである」といった断片的な事実の羅列になり、それらが「なぜ」結びついているのか（設計意図）が欠落しやすい。

### LLMによる理想的な解析アプローチ

LLMによる解析は、「必要な情報を都度取得する（オンデマンド）」RAG（Retrieval-Augmented Generation）的なアプローチが基本となります。

1.  **エントリーポイントの特定**: ユーザーの質問や目的に最も関連するファイルや関数を見つける。
2.  **依存関係のトレース（深掘りと波及）**: その関数が呼び出している別の関数（Deep Dive）、またはその関数を呼び出している箇所の特定（Impact Analysis）。
3.  **部分的な要約とコンテキストの蓄積**: トレースした結果を、その後の推論に使える形で圧縮・要約してプロンプト領域に保持する。

## 2. 既存の基本ツール（ファイルシステム/LSP）では解決できない問題

LLMが `ls`, `grep`, `cat` (または `view_file`, `find_by_name` など) や、単純なLSPのラッパー（定義へジャンプ等）を組み合わせて解析しようとした場合、以下の壁にぶつかります。

### a. 「意味の塊」へのアクセスの難しさ

`cat` や `view_file` は行単位・ファイル単位の操作です。LLMが知りたいのは「このクラスの役割」や「この関数の実装」といった**意味の塊（セマンティックな単位）**ですが、ファイルシステムツールでは「行番号XからYまで」といった物理的な指定が必要となり、その境界を特定するためだけに余分なツール呼び出し（ファイルの全体読み込み等）が発生します。

### b. ノイズの混入とコンテキストの圧迫

LSPを使って「参照元の検索」を行った場合、結果として大量の無関係なファイルパスや行が含まれることがあります。LLMはこれら一つ一つをさらに `cat` して確認しなければならず、すぐにコンテキストウィンドウが「無関係なコードの欠片」で埋まってしまいます。

### c. 「全体像（構造）」の喪失

ディレクトリツリー（`ls -R`）だけではコード間の論理的な関係性はわかりません。また、ファイルを次々と読んでいく過程で、LLMは「今自分がグラフのどの部分ツリーを辿っているのか」を見失いがちです。これは「要約が読んだ順番になんとなくで出てくる」原因でもあります。構造的なマッピングが存在しないため、平坦な事実の羅列になってしまうのです。

## 3. 本MCPサーバーの提供価値：「API付きのGraph RAG」によるナビゲーション

既存のロードマップではナレッジグラフの構築と「図表化（UML等への出力）」が定義されていますが、LLM自身がコードを自律的かつ動的に探索するためには、図表をパースするよりも直接グラフをクエリできるインターフェースが必要です。
本MCPサーバーの真の目的は、**「LLMがコードベースの構造を自在に航海するための『ナビゲーション・プロトコル（動的地図と羅針盤）』」**を提供することにあります。

### 提供機能の柱

1. **動的なグラフ更新（Lazy Loading)**: コードのASTや依存関係をオンデマンドで抽出し、常に最新の「グラフ構造」を提供する。
2. **対話的なトラバーサルAPI**: LLMが「次は関数Aの呼び出し元を教えて」「クラスBが実装しているプロトコルを辿って」といった**アクション（グラフ探索）**を起こすためのツール（Graph RAG API）を提供する。
3. **LLMフレンドリーなメタデータの付与**: ツール出力に自然言語の補足（ロードマップ 3.7準拠）を付加し、LLMが「次にどのノード（関数・クラス）を深掘りすべきか」を判断するヒントとする。

### アプローチ1: セマンティックな「コードチャンク」の提供（実装済み・強化）

- ファイルベースではなく、関数・クラスという「意味の塊単位」で情報を取得できるAPIを提供する（`get_function_chunk`等）。
- これによりLLMは、行番号を計算する手間なく、必要なコンテキストだけをクリーンに取得・保持できる。

### アプローチ2: ナレッジグラフ（依存関係グラフ）の構築・永続化と提供（Phase 3対応）

ロードマップ上の「依存関係グラフの解析・保持・永続化」機能の実現です。単なる「つながり」のデータではなく、LLMが「文脈（メタデータ）」として消費しやすい単位で提供します。（詳細はセクション4を参照）

## 4. ナレッジグラフ化の深掘り：構成要素と実装優先度

ロードマップ（Phase3）で定義されているナレッジグラフ機能を、LLMが「コードの全体像と役割」を効果的に把握できる順序（高い有用性とToken効率）で実装するための優先度を定義します。

### 構成要素と有用性（LLM視点）

| 要素名                                                  | ロードマップ対応                         | 有用性・効能                                                                                                                                                                                                                                                             | 優先度          |
| :------------------------------------------------------ | :--------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------- |
| **1. クラスリレーション<br>（継承・実装・依存）**       | 3.4 クラスの関係解析                     | **「アーキテクチャの骨格把握」に直結。**<br>LLMは通常「どっちがインターフェース（プロトコル）でどっちが具象クラスか」「このクラスはDI（依存性注入）で何を要求しているか」を知りたがります。これを提供することで、「MVCのどこにいるか」を瞬時に理解させることができます。 | **高** (Step 1) |
| **2. コールグラフ<br>（関数呼び出し関係）**             | 3.4 関数コールグラフ構築                 | **「影響範囲（Impact Analysis）」と「処理フローのトレース」に必須。**<br>「この関数を変更するとどこが壊れるか（逆引き）」「内部で順に何が呼ばれるか（順引き）」をコンテキスト長を消費せずにLLMに与えられます。                                                           | **中** (Step 2) |
| **3. ディレクトリ・モジュール<br>（パッケージ）マップ** | 3.2 チャンク粒度拡張<br>（パッケージ等） | **「トップダウンでのドメイン分割の理解」。**<br>単なる `ls` ではなく、「`/core/` はドメインロジック」「`/ui/` はプレゼンテーション」といった**モジュール間の境界（Importの方向）**を含めます。                                                                           | **中** (Step 2) |
| **4. データフロー<br>（状態の変遷）**                   | 3.4 データフロー解析                     | グローバル変数へのアクセス、シングルトンの参照など、データ更新フローの可視化。LLMにとって最も解析が困難な「状態変更」を提示できますが、静的解析での追跡難易度が高いです。                                                                                                | **低** (Step 3) |

### 最も重要（効く）な「クラスリレーション」と「コールグラフ」の違い

LLMにとって**最初に欲しいのは実は「クラスリレーション（アーキテクチャ）」**です。

- **なぜか**: コールグラフ（呼び出し関係）は細かすぎます。LLMがいきなり全てのコールグラフを渡されると、「どの関数から読むべきか」で迷子になります。
- まず「クラスAはクラスBを使っている」という**クラスリレーション**で「大枠（骨格）」を把握させ、次に特定の関数を読む際にその内部の**コールグラフ**を使って「詳細（血管）」を辿らせるのが、最もトークン効率の良いGraph RAGのアプローチとなります。

### （再掲）動的追従性（ctags問題）の解決策：「オンデマンド部分更新」と「ハイブリッドアプローチ」

ロードマップ 3.5「ナレッジグラフの永続化」において直面する「グラフデータベースがすぐに実コードと乖離して腐る（ctags問題）」について、以下のアーキテクチャで追従性を確保します。

#### 1. オンデマンド（Lazy）エッジ更新機構

グラフデータベース全体を常に完全な最新状態へバッチ更新することは避けます。代わりに、**「LLMが特定のチャンクや関係性を要求（クエリ）した瞬間に、その起点となるファイルだけの変更を検知（ハッシュ比較等）し、必要ならパースし直してグラフの部分ツリーをLazyに更新してから返す」** アプローチを取ります（関連: ロードマップ 4.2 キャッシュ戦略の改善）。

#### 2. LSP等既存の言語サーバーとのハイブリッド（委譲）

クラス間の複雑な依存関係やコールグラフの追跡において、自前で完璧な静的解析器を作り続けるのは現実的ではありません。
そこで、**正確なコールグラフや参照解決は既存の外部ツール（LSP等）に問い合わせる「アダプタ層」を設け、それをLLM向けの独自のグラフ構造（JSON等）に変換して保持するマッピング層** としての役割に徹します。解析の重労働は外部に任せ、本MCPは「LLM向けRAGのインターフェース」に集中します。

## 結論

LLMが大規模なコードベースにおいて「抽象（グラフ・構造）」と「具体（コードチャンク）」をスムーズに行き来するためには、専用のインターフェースが必要です。
既存のロードマップにある「ナレッジグラフの構築と永続化」という目標に対し、本プロジェクトはすべてを自前で静的に解析するのではなく、**「LSP連携とオンデマンド更新によるハイブリッドなGraph RAG API」を構築し、LLMエージェントがコードベースを自在に航海できる動的地図を提供すること**に注力すべきです。
