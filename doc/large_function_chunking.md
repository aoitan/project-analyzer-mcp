# 巨大関数のチャンク分割戦略

このドキュメントは、MCPサーバーにおける巨大関数のチャンク分割戦略について詳述します。LLMのコンテキストウィンドウの制約を考慮し、巨大な関数を扱いやすいサイズで取得できるようにします。

## 1. 背景と目的

大規模なソースコードベースでは、数千行に及ぶ巨大な関数が存在することがあります。これらの関数を一度にLLMに渡すと、コンテキストウィンドウを容易に超過し、LLMの処理能力を低下させる可能性があります。また、LLMが特定の関数のごく一部のみを必要とする場合でも、関数全体を読み込むのは非効率的です。

本戦略の目的は、巨大な関数を論理的または物理的な単位で分割し、LLMが必要な部分のみを段階的に取得できるようにする「ページング」機能を提供することです。

## 2. チャンク分割の粒度とアプローチ

### 2.1. 簡易的な物理的分割（ページング）

最初のステップとして、関数を意味的な構造で分割するのではなく、物理的な行数に基づいて分割する「ページング」アプローチを採用します。これは実装が比較的容易であり、LLMのコンテキストウィンドウの制約を緩和する即効性のある解決策となります。

- **閾値**: 関数のコード内容が一定の行数（例: 50行）を超えた場合にページングを適用します。この閾値は設定可能とします。
- **ページサイズ**: 1ページあたりの行数を指定できるようにします。デフォルト値はサーバー側で定義します（例: 50行）。

### 2.2. 将来的な意味的分割

将来的には、より高度なコード理解機能の一環として、関数内の論理ブロック（例: `if` 文、`for` ループ、ネストされた関数、クロージャなど）に基づいてチャンクを分割する意味的分割を検討します。これにより、LLMはより関連性の高いコードブロックに焦点を当てることができます。

## 3. ツールへのページング機能の導入

以下のツールにページング機能を追加します。

- `get_function_chunk`: 特定の関数のコードチャンクを取得するツール。
- `get_chunk`: チャンクIDでコードチャンクを取得するツール。

### 3.1. リクエストの追加引数

`get_function_chunk` および `get_chunk` ツールに以下のオプショナルな引数を追加します。

- **`pageSize`**: `number` (オプション)
  - 1ページあたりの行数を指定します。指定がない場合、サーバー側で定義されたデフォルト値（例: 50）が使用されます。
- **`pageToken`**: `string` (オプション)
  - 次のページまたは前のページをリクエストするためのトークンです。このトークンは、サーバー側で現在のページ情報（ファイルパス、チャンクID、開始行、終了行、ページサイズなど）をエンコードした文字列として生成されます。これにより、サーバーはステートレスにページングを処理できます。

### 3.2. 応答の追加情報

ページングが適用されたチャンクの応答には、以下の情報が含まれます。

- **`content`**: `string`
  - 現在のページのコード内容。
- **`isPartial`**: `boolean`
  - このチャンクが完全なコードチャンクの一部である場合に `true` となります。これにより、LLMは取得したチャンクが全体の一部であることを認識できます。
- **`totalLines`**: `number`
  - 元の巨大関数の総行数。LLMが全体の大きさを把握するのに役立ちます。
- **`currentPage`**: `number`
  - 現在のチャンクが何ページ目かを示します。
- **`totalPages`**: `number`
  - 元の巨大関数の総ページ数。
- **`nextPageToken`**: `string` (オプション)
  - 次のページをリクエストするために使用するトークン。最終ページの場合、このフィールドは存在しません。
- **`prevPageToken`**: `string` (オプション)
  - 前のページをリクエストするために使用するトークン。最初のページの場合、このフィールドは存在しません。

### 3.3. ページングのロジック

サーバー側では、以下のロジックでページングを処理します。

1.  **チャンクの取得**: まず、要求された `chunkId` または `filePath` と `functionSignature` に基づいて、完全なコードチャンクをキャッシュから取得します。
2.  **ページングの適用判断**: 取得したチャンクの行数が `pageSize` を超える場合、または `pageToken` が指定されている場合にページングを適用します。
3.  **`pageToken` の解析**: `pageToken` が提供されている場合、それをデコードして、要求されたページの開始行と終了行を特定します。
4.  **部分コンテンツの抽出**: チャンクのコード内容から、指定された範囲の行を抽出します。
5.  **メタデータの生成**: 抽出された部分コンテンツと、ページングに関するメタデータ（`isPartial`, `totalLines`, `currentPage`, `totalPages`, `nextPageToken`, `prevPageToken`）を含む新しい `CodeChunk` オブジェクトを生成します。
6.  **応答**: 生成された `CodeChunk` オブジェクトをLLMに返します。

## 4. ロードマップにおける位置づけ

この巨大関数のチャンク分割戦略は、MCPサーバー開発ロードマップの「フェーズ3: 高度なコード理解機能」における「3.2. コードチャンクの粒度拡張」の一部として位置づけられます。
