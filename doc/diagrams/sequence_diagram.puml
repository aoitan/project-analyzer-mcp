@startuml

actor "LLM/Agent" as LLM
participant "MCP Server" as Server
participant "AnalysisService" as AS
participant "ParserFactory" as PF
participant "SwiftParser" as SP
participant "KotlinParser" as KP
participant "SourceKitten" as SK
participant "Kotlin CLI" as KCLI
participant "File System" as FS
participant "Glob Library" as GL

== analyze_project ==
LLM -> Server: callTool("analyze_project", { projectPath: "..." })
activate Server
Server -> AS: analyzeProject(projectPath)
activate AS
AS -> FS: rm(chunksDir, recursive: true, force: true)
activate FS
FS --> AS: success
deactivate FS
AS -> FS: mkdir(chunksDir, recursive: true)
activate FS
FS --> AS: success
deactivate FS
AS -> GL: glob("**/*.swift", { cwd: projectPath, absolute: true })
activate GL
GL --> AS: swiftFiles
deactivate GL
AS -> GL: glob("**/*.kt", { cwd: projectPath, absolute: true })
activate GL
GL --> AS: kotlinFiles
deactivate GL
loop for each file in allFiles
  AS -> PF: getParser(language)
  activate PF
  PF --> AS: parser (SP or KP)
  deactivate PF
  alt if Swift file
    AS -> SP: parseFile(filePath)
    activate SP
    SP -> SK: structure --file filePath
    activate SK
    SK --> SP: JSON output
    deactivate SK
    SP -> FS: readFile(filePath)
    activate FS
    FS --> SP: fileContent
    deactivate FS
    SP --> AS: CodeChunk[]
    deactivate SP
  else if Kotlin file
    AS -> KP: parseFile(filePath)
    activate KP
    KP -> KCLI: java -jar kotlin-parser-cli.jar filePath
    activate KCLI
    KCLI --> KP: JSON output
    deactivate KCLI
    KP -> FS: readFile(filePath)
    activate FS
    FS --> KP: fileContent
    deactivate FS
    KP --> AS: CodeChunk[]
    deactivate KP
  end
  AS -> FS: saveChunk(CodeChunk)
  activate FS
  FS --> AS: saved
  deactivate FS
  AS -> AS: add to parsedProjects cache
end
AS --> Server: analysis completed
deactivate AS
Server --> LLM: { content: [{ type: "text", text: "Project analysis completed." }] }
deactivate Server

== get_chunk ==
LLM -> Server: callTool("get_chunk", { chunkId: "..." })
activate Server
Server -> AS: getChunk(chunkId)
activate AS
AS -> AS: check parsedProjects cache
alt chunk found in cache
  AS --> AS: return cached chunk
else chunk not in cache
  AS -> FS: loadChunk(chunkId)
  activate FS
  FS --> AS: chunkData
  deactivate FS
  AS --> AS: return loaded chunk
end
AS --> Server: { content: [{ type: "text", text: "..." }] }
alt chunk not found
  Server --> LLM: { content: [{ type: "text", text: "Chunk not found." }], isError: true }
else chunk found
  Server --> LLM: { content: [{ type: "text", text: "..." }] }
end
deactivate AS
deactivate Server

== list_functions_in_file ==
LLM -> Server: callTool("list_functions_in_file", { filePath: "..." })
activate Server
Server -> AS: listFunctionsInFile(filePath)
activate AS
AS -> PF: getParser(language)
activate PF
PF --> AS: parser
deactivate PF
AS -> parser: parseFile(filePath)
activate parser
parser -> FS: readFile(filePath)
activate FS
FS --> parser: fileContent
deactivate FS
alt if Swift file
  parser -> SK: structure --file filePath
  activate SK
  SK --> parser: JSON output
  deactivate SK
else if Kotlin file
  parser -> KCLI: java -jar kotlin-parser-cli.jar filePath
  activate KCLI
  KCLI --> parser: JSON output
  deactivate KCLI
end
parser --> AS: CodeChunk[]
deactivate parser
AS --> Server: functionsList
deactivate AS
Server --> LLM: { content: [{ type: "text", text: JSON.stringify(functionsList) }] }
deactivate Server

== get_function_chunk ==
LLM -> Server: callTool("get_function_chunk", { filePath: "...", functionSignature: "..." })
activate Server
Server -> AS: getFunctionChunk(filePath, functionSignature)
activate AS
AS -> PF: getParser(language)
activate PF
PF --> AS: parser
deactivate PF
AS -> parser: parseFile(filePath)
activate parser
parser -> FS: readFile(filePath)
activate FS
FS --> parser: fileContent
deactivate FS
alt if Swift file
  parser -> SK: structure --file filePath
  activate SK
  SK --> parser: JSON output
  deactivate SK
else if Kotlin file
  parser -> KCLI: java -jar kotlin-parser-cli.jar filePath
  activate KCLI
  KCLI --> parser: JSON output
  deactivate KCLI
end
parser --> AS: CodeChunk[]
deactivate parser
AS --> Server: functionContent
deactivate AS
Server --> LLM: { content: [{ type: "text", text: "..." }] }
alt function not found
  Server --> LLM: { content: [{ type: "text", text: "Function chunk not found." }], isError: true }
else function found
  Server --> LLM: { content: [{ type: "text", text: "..." }] }
end
deactivate Server

== find_file ==
LLM -> Server: callTool("find_file", { pattern: "..." })
activate Server
Server -> AS: findFiles(pattern)
activate AS
AS -> GL: glob(pattern, { absolute: true })
activate GL
GL --> AS: filePaths
deactivate GL
AS --> Server: filePaths
deactivate AS
Server --> LLM: { content: [{ type: "text", text: JSON.stringify(filePaths) }] }
deactivate Server

== find_function ==
LLM -> Server: callTool("find_function", { filePath: "...", functionQuery: "..." })
activate Server
Server -> AS: findFunctions(filePath, functionQuery)
activate AS
AS -> PF: getParser(language)
activate PF
PF --> AS: parser
deactivate PF
AS -> parser: parseFile(filePath)
activate parser
parser -> FS: readFile(filePath)
activate FS
FS --> parser: fileContent
deactivate FS
alt if Swift file
  parser -> SK: structure --file filePath
  activate SK
  SK --> parser: JSON output
  deactivate SK
else if Kotlin file
  parser -> KCLI: java -jar kotlin-parser-cli.jar filePath
  activate KCLI
  KCLI --> parser: JSON output
  deactivate KCLI
end
parser --> AS: CodeChunk[]
deactivate parser
AS --> Server: functionsList
deactivate AS
Server --> LLM: { content: [{ type: "text", text: JSON.stringify(functionsList) }] }
deactivate Server

@enduml